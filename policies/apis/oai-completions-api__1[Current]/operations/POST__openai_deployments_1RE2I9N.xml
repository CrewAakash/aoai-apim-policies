<!--
These policies are defined at the API level
-->
<policies>
	<inbound>
		<base />
		<!--Retrieves a parameter named "deployment" from the request and sets it as a variable.-->
		<set-variable name="deployment" value="@(context.Request.MatchedParameters["deployment"])" />
		<choose>
			<!--Checks if the "deployment" variable is either null, empty, or not set correctly.
				If true, returns a 401 Unauthorized response with a JSON error message..-->
			<when condition="@( ((string)context.Variables["deployment"])==null || ((string)context.Variables["deployment"]).Trim()=="" )">
				<return-response>
					<set-status code="401" reason="Unauthorized" />
					<set-header name="Content-Type" exists-action="override">
						<value>application/json</value>
					</set-header>
					<set-body>{
              "error": "deployment is either empty, not present or not set correctly."
              }</set-body>
				</return-response>
			</when>
			<otherwise>
				<!--Otherwise, sets a query parameter "api-version" to "2023-05-15"-->
				<set-query-parameter name="api-version" exists-action="skip">
					<value>2023-05-15</value>
				</set-query-parameter>
			</otherwise>
		</choose>
		<!-- Keyless authentication - Utilizes managed identity for authentication, retrieving an access token and setting it in the Authorization header. -->
		<authentication-managed-identity resource="https://cognitiveservices.azure.com" output-token-variable-name="msi-access-token" ignore-error="false" client-id="xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx" />
		<set-header name="Authorization" exists-action="override">
			<value>@("Bearer " + (string)context.Variables["msi-access-token"])</value>
		</set-header>
		<!-- Roundrobin load-balancing with 2 deployments per model type in the 2 backends -->
		<cache-lookup-value key="backend-counter" variable-name="backend-counter" />
		<!-- Looks up a value from cache named "backend-counter" and sets it as a variable.
			 Checks if the "backend-counter" variable exists, and if not, initializes and stores it in the cache with a duration of 100 seconds.
			 Uses a round-robin approach to switch between two backend services based on the value of "backend-counter".
			 Stores the updated "backend-counter" value in the cache and sets a variable indicating which backend service was invoked. -->
		<choose>
			<when condition="@(!context.Variables.ContainsKey("backend-counter"))">
				<set-variable name="backend-counter" value="1" />
				<cache-store-value key="backend-counter" value="1" duration="100" />
			</when>
		</choose>
		<choose>
			<when condition="@(int.Parse((string)context.Variables["backend-counter"]) % 2==1)">
				<set-backend-service backend-id="oai-gateway-sample" />
				<set-variable name="backend-counter" value="2" />
				<cache-store-value key="backend-counter" value="2" duration="100" />
				<set-variable name="OpenAI-Instance-Invoked" value="oai-gateway-sample" />
			</when>
			<when condition="@(int.Parse((string)context.Variables["backend-counter"]) % 2==0)">
				<set-backend-service backend-id="oai-gateway-sample2" />
				<set-variable name="backend-counter" value="1" />
				<cache-store-value key="backend-counter" value="1" duration="100" />
				<set-variable name="OpenAI-Instance-Invoked" value="oai-gateway-sample2" />
			</when>
			<otherwise>
				<set-backend-service backend-id="oai-gateway-sample" />
				<set-variable name="backend-counter" value="1" />
				<cache-store-value key="backend-counter" value="1" duration="100" />
				<set-variable name="OpenAI-Instance-Invoked" value="oai-gateway-sample" />
			</otherwise>
		</choose>
	</inbound>
	<backend>
		<!-- Forwards the incoming request to the backend while buffering the request body.-->
		<forward-request buffer-request-body="true" />
	</backend>
	<outbound>
		<base />
		<!--Converts the response body into a JSON object.
			Adds a property named "backend-counter" with the value from the "backend-counter" variable.
			Returns the modified response body.-->
		<set-body>@{
            JObject body = context.Response.Body.As<JObject>();
            body.Add(new JProperty("backend-counter", ((string)context.Variables["backend-counter"])));
            return body.ToString();
            }</set-body>
	</outbound>
	<on-error>
		<!--Inherits the base behavior for error handling.-->
		<base />
	</on-error>
</policies>